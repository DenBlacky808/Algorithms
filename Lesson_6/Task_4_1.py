import random
import sys


SIZE_5 = 240
MIN_ITEM = 0
MAX_ITEM = 10
array_240 = [random.randint(MIN_ITEM, MAX_ITEM) for _ in range(SIZE_5)]


array_set = set(array_240)
repeat_number = None
cnt_repeat = 0
for item in array_set:
    cnt = array_240.count(item)
    if cnt > cnt_repeat:
        cnt_repeat = cnt
        repeat_number = item
print(repeat_number)

sum_usage = 0
var_list = [array_set, repeat_number, cnt_repeat, cnt, item]
for variable in var_list:
    sum_usage += sys.getsizeof(variable)

print(sum_usage)

# mac os 10.14.6 python 3.8 64bit
#                               результаты
# ram usage
# 	    1 version	            2 version 	        3 version
#       840 байт                2348 байт           2932 байт
#
# Несмотря на то что 3-я версия реализации выигрывает в скорости работы,
# она использует под переменные больше памяти почти в три раза.
# С учетом незначительного преимущества в плане скорости я бы выбрал первый вариант.
# 2-ой вариант остается в аутсайдерах теперь еще и по использованию памяти.

# вывод: еще раз убедился что функция count имеет хорошую реализацию и сходу придумать лучшее
# у меня не получилось бы.


# speed
# N	    1 version	            2 version 	        3 version

# 15	0.004254538000000002	0.038777797	        0.003181919999999998
# 30	0.008713084	            0.085467363	        0.004829841999999994
# 60	0.015396542999999999	0.294511312	        0.009556648000000001
# 120	0.029859443999999992	1.246790759     	0.040001782
# 240	0.07157505800000001	    4.841161119000001	0.066344887
# 480   0.16183675300000003                         0.11694072
# 960   0.329998855                                 0.268649696

# По скорости работы можно сделать вывод, что встроенная функция count()
# не так уж плоха и вполне пригодна для решения данной задачи. Сложность решения 1 и 3 линейны.
# Сложность решения 2 квадратична.
# 3 решение показывает небольшой прирост в производительности.
# по отчету cProfile можно сделать вывод, что в первой версии реализации 11 раз обращаемся к функции count.
# Функция count  использует алгоритм Бойера - Мура, что по версии википедии является
# эффективным алгоритмом поиска.
# Однако, 3 решение является своего рода индексацией, поэтому 3-й алгоритм быстрее 1-го и 2-го.
